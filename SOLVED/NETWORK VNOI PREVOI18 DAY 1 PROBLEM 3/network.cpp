/*⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⡟⢤⠓⣜⢢⢣⣙⣾⣛⢯⣟⢿⡻⣟⡿⣿⣻⡟⣿⡿⣿⣶⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⡿⢆⢣⢛⣬⡲⣏⡟⡶⣭⣛⣮⢟⣽⣹⣛⣷⣿⣝⢧⡿⣜⢿⡹⣟⡿⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⢿⠟⡩⡍⢦⣱⢎⡿⣹⢖⣻⡵⣻⣝⣧⣟⣾⣹⢮⢷⣛⡾⣼⣿⣞⣳⣭⡻⣽⣺⠵⣏⢿⣻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⢏⣻⣌⣦⣱⣞⣧⣛⣮⢷⡹⣞⢧⣻⠵⣞⣧⣛⡶⢯⣻⣻⢼⡳⢿⣿⣿⣷⡭⢷⣻⣿⣻⣾⣯⢳⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⠾⠿⠛⠛⠛⠋⡉⢉⡉⠙⠙⢛⢛⠛⠻⠿⢿⣿⣼⣶⣯⡽⣏⡷⣭⢷⣛⡯⢿⣿⣿⣿⢧⣏⣿⣷⣻⣿⣧⣟⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣼⣿⣥⡷⠞⠛⢛⣻⣿⣛⠛⠉⠉⣙⣿⣿⠿⠛⠖⢶⢦⣤⣌⣉⠙⠛⠿⣾⣽⣞⡧⣟⢯⡞⣽⣻⣿⣼⣿⣿⣿⣿⣿⣮⡽⣿⣷⣶⣶⣶⣶⣶⠶⣶⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢼⣿⢏⣽⠟⠛⢶⣶⣟⣉⣈⣙⣷⣶⣟⣋⣁⣙⡳⣶⠞⠛⠛⠛⢾⣍⠛⠳⢦⣤⣉⠛⠿⢷⣿⣞⣳⡭⣟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣏⠀⠀⠈⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣠⣾⣿⣿⣷⡾⡿⠿⢿⠻⣟⣻⢛⡟⣻⢛⡟⡿⢿⢿⣿⣿⣶⣶⣤⣤⣙⣷⣄⣠⣤⣭⣿⢶⣤⣉⠛⢷⣿⣿⣿⣿⣿⡟⠻⣿⣿⣿⣿⣿⣿⠿⠛⠻⣦⣀⣤⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣤⣶⣶⡿⢿⠿⣛⠻⣍⠻⣔⣣⢞⡱⣏⠞⣽⢲⣥⢻⡜⣷⢻⡼⣫⢟⣮⢶⣭⠷⣯⢟⡿⡿⣿⣿⣷⣤⣄⡠⠈⣻⣏⠓⢦⣌⡻⢿⣿⣿⣧⠀⠀⠈⠉⠛⠉⠀⠀⠀⠀⠈⣹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣶⣿⡿⣟⠛⠯⣍⢦⡙⣎⢳⡭⢳⢎⠿⣸⡱⣎⢗⢮⢻⡜⣧⢞⣧⢻⡜⣧⡻⣵⣫⢞⣳⣞⣻⣭⣟⡾⣽⣳⢯⣻⡽⣿⣿⣷⣴⣿⣦⣦⣬⣿⣷⣙⠻⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣋⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣶⣿⣿⣻⣯⣭⣶⣵⣬⣭⣳⣜⢦⡝⢬⡓⡞⡭⣎⠟⣥⢳⡝⣮⢏⡷⣹⢎⡿⣜⡧⣟⣳⡽⢧⡯⣟⡵⣞⡷⣞⡾⣽⣳⢯⣟⣷⣻⣳⡽⣏⡿⣿⣿⣷⣬⣻⣛⣿⣿⣾⣻⢶⣄⠀⠀⠀⠀⠀⣠⡞⠉⠀⠈⠙⢷⡄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣠⣴⣾⣿⣿⠿⢟⡻⢍⠯⢭⡹⢍⠯⣙⡛⣛⢿⣿⠟⠿⠷⣷⣮⣽⣎⡳⣞⡵⣫⢞⣳⡻⣞⣧⢟⡾⣱⡟⣯⠷⣏⡿⣽⠾⣝⡷⣯⢷⣻⢮⡷⣯⢷⣻⣽⣻⢷⣯⢿⣿⣿⣿⣧⣸⣏⢿⡷⣿⣷⣄⠀⠀⠐⣿⠀⠀⠀⠀⢀⣾⣷⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣠⣴⣿⣿⢿⡛⠵⣊⡝⢦⣙⢮⡙⢦⡙⣎⠳⣥⣚⣶⠟⠁⠀⠀⠀⠀⠈⠉⠛⠛⠿⢾⣷⣯⣳⢏⡷⣞⣯⢟⣷⣻⡽⣻⡽⣽⡞⣿⡽⣻⣞⣯⠿⣽⣳⢯⣟⣷⣫⣽⣻⣞⡿⣮⢟⣿⣿⣿⣿⣜⣿⣤⣽⣿⣧⡀⠀⠻⣦⣀⠠⣄⣸⣾⠏⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢠⣾⣿⣿⣯⣇⢧⡙⢮⡱⢞⡱⢎⠶⣙⢦⡙⢦⣻⣼⠟⠁⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠿⢿⣽⣞⡿⣞⣳⣟⣷⣻⢷⣻⢷⣻⢷⣛⣾⣻⠷⣯⣟⣾⣳⣟⣾⣳⢯⢿⣽⣻⣞⡷⣯⢿⣿⣿⣿⣿⣯⣿⠇⠀⠀⠈⠙⠛⠛⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⣰⣿⣿⠋⢉⡉⠛⠿⣾⣥⡚⡥⢛⡬⢳⡍⠶⣹⣽⡿⠃⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⢠⡏⠀⠀⠀⠀⠀⠀⠈⠉⠛⠿⣷⣟⣾⡽⣯⣟⣯⣟⣯⣟⡾⣽⣻⢷⣻⣞⣷⡻⣾⢽⣯⣟⣾⣳⢯⡿⣽⢯⣟⡿⣿⣿⣿⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢠⣿⣿⠃⠌⡘⣀⠣⠐⡠⠙⠿⣷⣭⢒⢧⣚⣵⣿⠟⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⠀⡾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠿⣷⣿⡾⣽⢾⣽⣻⢷⣯⣟⣷⣻⢾⡽⣯⣟⣶⣻⢾⡽⣯⢿⣽⣻⢾⣽⣳⢿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⣼⣿⡟⡀⢂⠱⢀⠊⡑⢠⢁⠂⠌⣿⣯⣶⣿⣿⠋⠀⠀⠀⠀⠀⠀⡼⠁⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢩⡿⠿⣿⣾⣽⣻⢾⡽⣾⡽⣯⣟⣷⣻⢾⡽⣯⣟⣷⣻⢾⣽⣻⢾⣽⣻⢾⡽⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢿⣿⡷⠀⡅⢚⠠⢁⢂⠡⢊⡐⠀⣿⣿⣿⡿⣡⠄⠀⠀⠀⠀⠀⣼⠃⠀⠀⢠⡆⠀⠀⣿⠁⠀⠀⠀⢠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣷⠀⠈⠙⠻⢿⣿⣽⣳⣟⣷⣻⢾⡽⣯⣟⣷⣻⢾⣽⣻⢾⣽⣻⢾⡽⣯⣟⣷⡻⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢸⣿⣿⠐⡀⢣⠌⢂⠐⠌⡂⠄⢃⣿⣿⠟⣴⠋⠀⠀⠀⠀⠀⢰⡏⠀⠀⠀⣼⠀⠀⣸⣿⠀⠀⠀⠀⠈⣧⠀⠀⠀⠀⡄⠀⠀⠀⠀⠀⠀⢿⣿⠀⠀⠀⠀⡀⠈⠛⠿⣾⣷⣯⣟⡿⣳⣟⡾⣽⣻⢾⣽⣻⢾⡽⣯⣟⣷⣻⢾⡽⣯⢿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⢿⣿⣧⠐⢡⠂⡌⠰⣈⠰⢈⣸⣿⠫⣼⠃⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⢰⡇⠀⢠⣿⢿⡷⠶⠀⠀⠀⠘⢷⡀⠀⠀⢹⠀⠀⠀⠀⠀⢀⣸⣿⡄⠀⠀⠘⣿⠀⠀⠀⠈⣽⠻⢾⣿⣽⡾⣽⢿⣽⣻⢾⡽⣯⣟⣷⣻⢾⡽⣯⢿⣽⣻⣞⡿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠈⣿⣿⣧⠂⡌⠤⠑⡀⠆⣼⣿⠃⣼⠃⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⢠⣿⡇⠀⣼⡏⢸⣇⠀⣀⠀⠀⠀⠈⠹⣦⡀⠈⢧⠀⠀⠀⠀⢀⡿⠈⣷⠀⠀⠀⢹⡆⠀⠀⠀⢻⡇⠀⠈⠙⠻⣿⣟⣾⡽⢯⣿⡽⣾⣳⣯⢿⡽⣯⣟⣾⣳⢯⣟⡿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠈⢿⣿⣷⡀⢂⠔⡠⢹⣿⢃⣾⡏⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⢠⣿⠹⡇⢠⡟⠀⠀⢿⠀⢸⡆⠀⠀⠀⠀⠀⠙⠶⣜⣧⠀⠀⣴⣾⠃⠀⢸⣇⠀⠀⢸⢿⡀⠀⠀⢘⣇⠀⠀⠄⠀⠀⠉⠛⠿⣿⣷⣻⣷⣻⣞⡿⣽⣳⣟⡾⣽⣻⢾⡽⣯⣿⣿⣦⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠹⣿⣿⣶⣈⢰⣿⢃⣾⡿⠀⠀⠀⠀⠀⠀⠀⢀⢿⠀⢀⡾⠋⠀⣇⣼⠁⠀⠀⣘⣧⠈⣿⡄⠀⠀⠀⠀⠀⠀⠀⠈⠃⣸⣧⣇⣀⡀⠀⢻⣆⠀⢨⠈⢳⡄⠀⠈⣿⠀⠀⠀⠀⠘⠦⣄⠀⠸⣏⠛⠷⣿⣾⣽⣳⣟⡾⣽⢯⣟⣯⣟⣷⢻⣿⣿⣷⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⠻⢿⣿⣿⢧⣿⣿⡇⠀⣶⠀⠀⠀⠀⠀⢸⣻⠀⣾⠁⣠⣴⣿⣿⣷⣶⣶⣤⡙⢧⣼⢻⣄⠀⠀⠀⠀⠀⢠⠀⢀⡿⢛⣩⣥⣴⣶⣶⣿⣦⣧⣀⠀⠻⣆⠀⣿⠀⠀⠀⠀⠀⠀⠈⠙⢷⣿⠀⠀⠈⢻⡿⢿⣾⣽⣯⣟⡾⣽⡾⣽⣫⢿⣿⣿⣿⡄⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣾⣿⣿⠀⢀⡿⠀⠀⠀⠀⠀⠈⣿⣾⣯⣾⣿⠿⠛⣿⡿⢟⢿⣿⣿⣶⡜⣇⠙⢦⡀⠀⠀⠀⢸⣧⡾⣧⠿⠿⣿⣟⠿⣻⠿⣿⣿⣿⣿⣦⡙⢷⣿⠀⠀⠀⠀⠀⠀⠀⠀⠠⣿⠃⢀⡀⢹⣿⢢⠏⣝⡻⢿⣿⣶⣿⣳⢯⡿⣿⣿⣿⣿⣄⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢸⣷⡏⠙⣿⠀⢸⣿⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⠁⠀⢸⣿⣯⣟⣞⣯⣿⣿⡆⠀⠀⠀⢻⢦⣄⠀⠐⢿⠁⠀⠀⣼⣿⣿⣏⣳⢻⡴⣻⢿⡟⢿⣿⣦⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠈⠙⣾⣿⣌⠻⣜⡹⢶⣌⢻⡙⡿⢿⣿⣿⣿⣿⣿⣿⠄⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⡇⠀⣟⠀⣾⣿⡀⠀⢸⡄⠀⠀⠈⣿⡎⣿⠀⠀⢺⠋⠉⢿⣿⣿⣿⣿⣧⠀⠀⢀⡿⠖⠋⠙⠲⢾⣇⠀⣸⡏⠉⢻⣿⣿⣷⣷⣿⣿⡇⠀⢻⣿⣷⡤⠀⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⡇⢸⣿⢢⡛⢬⠓⡧⢎⣧⣹⣼⣷⣾⣿⣿⣿⡿⠟⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠃⣿⠀⣿⠸⣇⠀⠀⢷⠀⠀⠀⢹⣷⠈⠀⠀⠘⣿⠟⠋⠻⣿⠿⠛⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠹⡟⠛⠛⠿⠿⠟⢿⣿⣿⡇⠀⣼⣿⠉⠀⠀⠀⠀⠀⠀⠀⣧⢸⡇⠀⠀⢻⣸⡿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠛⠛⠋⠉⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡀⣿⠀⢹⣆⠀⠘⢷⡀⠀⠀⢻⡇⠀⠀⠀⠹⣆⠀⠀⠀⠀⢠⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⡀⠀⠀⠀⠀⠀⠀⣹⠃⠘⣫⠇⠀⠀⠀⠀⠀⠀⠀⢰⣇⣾⠁⠀⠀⠘⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣷⣸⣇⠀⣿⣦⡀⠀⠛⢦⣄⡀⠹⣄⠀⠀⠀⠉⠳⠄⠀⠰⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢷⣄⠀⠀⠀⢀⡴⠋⢀⡼⠃⠀⠀⠀⢀⣴⠖⠀⠀⣾⢹⡇⠀⠀⠀⠘⢻⡧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢧⡹⣦⣸⣏⠃⢄⠀⠀⠹⣿⡟⠛⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⢀⣾⣋⣠⣴⢋⣀⣀⣀⣤⡶⠋⠁⠀⠀⣼⢯⡿⡇⠀⠀⠀⠀⠸⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣽⣿⡄⠀⠀⠄⠀⠛⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠞⠛⠙⠉⠉⠉⠉⢹⣿⡿⠋⠀⠀⠀⠀⣼⣿⠟⠁⢸⡀⠀⠀⠀⠀⢻⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⡟⠻⣧⠀⠀⠀⠐⢀⡸⣿⠳⣦⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡾⣻⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣶⡟⠉⠀⠀⠀⠀⢀⣼⠟⠁⠀⠀⠘⣇⠀⠀⠀⠀⠈⢿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠟⠀⠀⡹⣆⠀⠀⠀⠀⠙⢿⡄⠀⠉⠙⣻⣶⣦⣤⣤⣤⣤⣤⣿⣿⣏⣀⣀⣀⣀⣀⣀⣠⣤⣴⣤⣶⡶⠾⠛⠋⢩⡟⠀⠀⠀⠀⢀⣴⠟⠁⠀⠀⠀⠀⠀⢹⡀⠀⠀⡀⠀⠈⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⠋⠀⠀⢰⡧⠙⣧⡀⠀⠀⠀⠈⢿⣄⣴⣿⣭⠷⠟⠛⠛⠛⠛⢻⣿⣾⣿⣭⣉⣽⣿⡿⠛⠉⠁⠀⠀⢹⣇⠀⠀⠀⣾⠁⠀⠀⣠⡴⠟⠁⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⢱⡀⠀⠘⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡟⠁⠀⠀⣠⣿⠁⠀⠈⠻⣦⡀⠀⠀⠸⣿⣿⣋⠀⠀⠀⠀⠀⠀⢘⣿⣛⣿⣀⡤⣿⡿⢁⣤⣶⣀⣀⣀⣀⣀⣹⣧⠀⢸⡇⢀⣴⡞⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⡇⠀⠀⠈⣷⡀⠀⠘⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⠏⠀⠀⢀⣼⣿⠃⠀⠀⠀⠀⠀⠹⣦⣄⠀⣿⢻⡇⠀⠀⠀⠀⠀⠀⠉⠉⠉⣉⠀⠀⡿⠚⣋⣿⣿⡏⢻⣿⣿⣿⣿⡇⠀⠸⣷⠋⠘⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡌⡷⠀⠀⠀⣿⣷⡄⠀⠘⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⠃⠀⢀⣴⠟⢹⠇⠀⠀⠀⡀⠀⠀⠐⡏⠈⢳⣾⢟⣿⡆⠀⠀⠀⠀⣷⡆⠀⠀⣠⣴⡾⠿⠾⣟⣻⣿⣿⣿⣿⣷⢯⣿⣿⠀⠀⠙⢷⣄⡘⢷⣀⣀⡀⠀⠀⠀⠀⠀⠀⢸⣷⢡⠀⠀⠀⠁⣿⢻⡄⠀⠸⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⠃⠀⣠⠟⠁⠀⣿⠀⠀⡆⢠⡷⠀⠀⣰⣏⣠⡾⠋⢹⣿⣧⢀⣤⡀⠀⣹⣦⣄⢰⣿⣹⡆⠀⠀⠈⡗⣿⣿⢯⡟⣿⣿⣿⣿⡄⠀⠀⠀⠈⠉⠋⠉⠁⠀⣤⠀⠀⠀⠀⠀⡸⣿⡧⠀⠀⠀⠀⣿⠀⠹⣆⠀⢹⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣼⠇⢀⡾⠋⠀⠀⠀⣇⠀⢀⣏⣿⣿⠀⠘⠛⠋⠁⠀⠀⣿⡐⣿⠹⢿⠟⠁⢿⡿⡿⣾⣿⣷⣄⣀⣀⣰⠇⣿⣟⡾⡽⢯⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⣿⣿⣷⠄⠀⠀⠀⣿⠂⠀⠘⣇⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢰⡟⠀⣼⠁⠀⠀⠀⠰⣧⠀⠀⣿⡏⢿⡄⠀⠀⠀⠀⠀⠀⢹⣇⢸⣶⣾⣷⡦⣄⣀⡈⢿⣿⠟⠋⣿⣿⣿⣰⣿⡽⢾⡽⣏⣿⣾⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⠀⠀⠀⠀⠀⣾⠃⣿⠀⠀⠀⠀⣿⠀⠀⠀⢹⡄⢹⡃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠸⣇⠀⣿⠀⠀⠀⠀⠀⢹⡄⠀⢿⡃⠈⣷⠀⠀⣆⠀⠀⣀⣤⣿⣿⣿⢉⠉⠈⠻⠿⠁⢀⠀⠀⢰⣿⣷⣭⣿⣿⣽⣯⣷⣿⣿⣿⣿⣿⣿⣶⣷⣦⡀⠀⠀⠀⣼⣿⠀⠀⠀⠀⣸⠏⠀⣿⠀⠀⠀⣼⠏⠀⠀⠀⢸⡇⣼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣀⣀⣀⣤⣿⣄⢻⡷⠶⠶⠶⠶⠬⣷⡄⢸⣧⣄⣬⣷⣄⠹⣦⣼⡿⠷⣯⣛⣿⡎⠀⠀⠀⠀⠀⠈⠁⠀⢀⣽⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣷⣟⣾⣻⣿⣿⣿⣿⣷⣾⣿⣧⡀⠀⠀⣰⠏⠀⢠⡇⠀⠀⣰⠟⠀⠀⠀⠀⢸⣧⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⣤⣶⡿⠟⠛⠉⠁⠀⠀⠈⠻⢷⣤⣤⠄⠀⠀⠀⠻⣾⣧⠀⠀⠈⢹⣿⣿⣿⡄⠀⠀⣿⠈⢷⣦⣤⣤⣤⡶⣶⣶⣻⣽⣟⣉⣩⡿⠶⠾⣭⡿⢦⣄⢀⡟⢿⣯⣯⣟⢿⣿⣿⣿⣿⣿⣿⣿⣶⡾⠷⠶⠞⣿⠁⢀⣴⠿⠶⠾⠛⠛⢻⣿⠿⠳⠶⠷⠶⠶⠶⣦⣤⣤⣀⣀⠀
⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⠄⠀⠼⣿⣿⣿⣿⡀⠀⠘⢦⣌⠉⠙⠛⠋⠻⠉⣽⣿⣿⣿⣿⣧⠀⠀⠀⠀⠙⢦⣬⣿⡇⠈⢛⠻⢾⣿⣾⣿⠿⠿⢿⡉⢡⣿⣧⠀⣤⡾⠷⠖⠋⠀⠀⠀⠐⠒⠚⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠤⠤⢤⣤⣀⣹⣿⣿⣿⣷⣂⣤⣤⣽⣷⣦⣤⣀⣀⣼⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⢹⣦⣷⠠⣈⣧⣀⡈⠻⠦⣄⣀⣨⣿⣟⣛⡓⠚⠛⠒⠒⠲⠶⠞⠳⠤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠷⢦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠛⠛⠛⠋⠉⠉⠉⠀⠀⠀⠀⠈⠁⠉⠉⠉⠉⢻⣿⣿⣿⣿⣿⣇⣤⣴⠶⠾⠛⠛⠿⠶⢦⣭⣥⠴⠶⠞⠛⠉⠀⠀⠈⠉⠉⠙⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠠⠐⠀
⠀⠀⠀⠉⠉⠉⠀⡐⠒⠂⠤⠴⠤⠤⠤⠤⢤⣤⣤⣤⣤⣤⣀⣀⣀⡀⠀⠀⠀⠀⠀⢠⣤⣶⠶⠶⢶⡴⣦⣤⣤⣤⣍⣋⡛⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⣀⠀⣀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢀⣀⣀⣠⣄⣤⣤⣄⡠⠤⠤⠔⠂⠀⠀⠀⠀⠀⠀⠀*/    
#include <bits/stdc++.h>
#define ll long long
#define ld long double 
#define inf 0x3f3f3f3f
#define fi first
#define se second
//#define cout cerr
#define FILE "uwu" 
using namespace std;
//**Variable**//
ll n, m;
ll u,v,w; 
char t;
ll x, y, k;
vector<pair<ll,ll>> g[200001];
ll chainHead[200001];
ll chainPos[200001];
ll arr[200001];
ll h[200001];
ll sz[200001];
ll up[200001][21];
ll start[200001];
ll startVer[200001];
ll lst[200001];
ll lstVer[200001];
ll timer;  
ll ans[200001];
pair<ll,ll>edge[200001];
//**Struct**//
struct inp{
    ll u, v;
}input[200001];

struct Query{
    char t;
    ll x, y, k;
    ll id;
}query[200001];

struct Node{
    ll val, lz;
}T[8*200001], C[8*200001];
//**Function**//
bool cmp(Query x , Query y){
    return x.k > y.k;
}
void DFS(ll u){
    sz[u] = 1;
    timer ++ ;
    start[u] = timer;
    startVer[timer] = u;
    for(ll i = 1 ; i<=20; i++){
        up[u][i] = up[up[u][i-1]][i-1];
    }
    for(auto it : g[u]){
        ll v = it.fi;
        ll w = it.se;
        if(v == up[u][0])continue;
        edge[v]={w,v};
        up[v][0] = u;
        h[v] = h[u] + 1;
        DFS(v);
        sz[u] += sz[v];
    }
    lst[u] = timer;
    lstVer[timer] = u;
}
void HLD(ll u, ll head){
    chainHead[u] = head;
    timer++;
    chainPos[u] = timer;
    arr[timer] = u;
    ll nxt = -1;
    for(auto it : g[u]){
        ll v = it.fi;
        if( v == up[u][0] )continue;
        if(nxt == -1 || sz[nxt] < sz[v]){
            nxt = v;
        }
    }
    if( nxt  != -1  && nxt != up[u][0])HLD(nxt,head);
    for(auto it : g[u]){
        ll v = it.fi; ll w = it.se;
        if(v == up[u][0] || v == nxt)continue;
        HLD(v,v);
    }
}
void lazy(ll id,ll l, ll r){
    if (C[id].lz == 0)return; 
    ll val = C[id].lz;
    C[id].val += val*(r-l+1);
    C[id*2].lz += val;
    C[id*2+1].lz +=val;
    C[id].lz = 0;
    return ;
}
void update(ll id, ll l,ll r, ll u, ll v, ll val){
    lazy(id,l,r);
    if( l > r || u > v || l > v || u > r )return;
    if( u <= l && r <= v){
        C[id].val += val*(r-l+1);
        C[id*2].lz += val;
        C[id*2+1].lz += val;
        return;
    }
    ll mid = (l + r)/2;
    update(id*2,l,mid,u,v,val);
    update(id*2+1,mid+1,r,u,v,val);
    C[id].val = C[id*2].val + C[id*2+1].val;
}
ll get(ll id, ll l, ll r, ll u, ll v){
    lazy(id,l,r);
    if( l > r || u > v || l > v || u > r )return 0;
    if( u <= l && r <= v){
        return C[id].val;
    }
    ll mid = (l + r)/2;
    return get(id*2,l,mid,u,v) + get(id*2+1,mid+1,r,u,v);
}
void lazyH(ll id,ll l, ll r){
    if (T[id].lz == 0)return;
    ll val = T[id].lz;
    T[id].val += val*(r-l+1);
    T[id*2].lz += val;
    T[id*2+1].lz +=val;
    T[id].lz = 0;
    return ;
}
void updateH(ll id, ll l, ll r, ll u, ll v, ll val){
    lazyH(id,l,r);
    if( l > r || u > v || l > v || u > r )return;
    if( u <= l && r <= v){
        T[id].val += val*(r-l+1);
        T[id*2].lz += val;
        T[id*2+1].lz += val;
        return;
    }
    ll mid = (l + r)/2;
    updateH(id*2,l,mid,u,v,val);
    updateH(id*2+1,mid+1,r,u,v,val);
    T[id].val = T[id*2].val + T[id*2+1].val;
}
ll getH(ll id, ll l, ll r, ll u, ll v){
    lazyH(id,l,r);
    if( l > r || u > v || l > v || u > r )return 0;
    if( u <= l && r <= v){
        return T[id].val;
    }
    ll mid = (l + r)/2;
    return getH(id*2,l,mid,u,v) + getH(id*2+1,mid+1,r,u,v);
}
ll find_cur(ll l,ll r,ll k)
{
    while (l<=r){
        int mid = (l+r)/2;
        if (edge[mid].fi>=k)
            r=mid-1;
        else
            l=mid+1;
    }
    return l;
}
void preprocess(){
    timer = 0;
    up[1][0] = 1;
    h[1] = 1;
    DFS(1);
    timer = 0;
    HLD(1,1);
    update(1,1,n,1,n,1);
    updateH(1,1,n,1,n,1);
    sort(edge+1,edge+n+1);
    sort(query+1,query+m+1,cmp);
}
int main()
{
    ios_base::sync_with_stdio(false);cin.tie(NULL);
    // freopen(FILE".inp","w",stdout);
    freopen(FILE".inp","r",stdin);
    freopen(FILE".out","w",stdout);
    cin >> n >> m;
    for(ll i = 1; i<n; i++){
        cin >> u >> v >> w;
        input[i] =  {u,v};
        g[u].push_back({v,w});
        g[v].push_back({u,w});
    }
    for(ll i = 1; i<=m; i++){
        cin >> t;
        if(t == 'P'){
            cin >> x >> y >> k;
            query[i] = {t,x,y,k,i};
        }else{
            cin >> x >> k;
            query[i] = {t,0,x,k,i};
        }
    }
    preprocess();
    ll prev=n;
    for (ll i=1;i<=m;i++)
    {
        ll t=query[i].t;
        ll l=query[i].x;
        ll r=query[i].y;
        ll k=query[i].k;
        ll id=query[i].id;
        ll cur=find_cur(1,prev,k+1);
        for (ll i=cur;i<=prev;i++)
        {
            update(1,1,n,chainPos[edge[i].se],chainPos[edge[i].se],-1);
            updateH(1,1,n,start[edge[i].se],start[edge[i].se],-1);
        }
        prev=cur-1;
        if (t == 'P')
        {
            while (chainHead[l]!=chainHead[r])
            {
                if (h[chainHead[l]]<h[chainHead[r]])
                {
                    ans[id]+=get(1,1,n,chainPos[chainHead[r]],chainPos[r]);
                    r=up[chainHead[r]][0];
                }
                else
                {
                    ans[id]+=get(1,1,n,chainPos[chainHead[l]],chainPos[l]);
                    l=up[chainHead[l]][0];
                }
            }
            if (h[l]>h[r])
                ans[id]+=get(1,1,n,chainPos[r]+1,chainPos[l]);
            else
                ans[id]+=get(1,1,n,chainPos[l]+1,chainPos[r]);
        }
        else
        {
            ll x=input[r].u;
            ll y=input[r].v;
            if (x==up[y][0])
                ans[id]=getH(1,1,n,start[y]+1,lst[y]);
            else
                ans[id]=getH(1,1,n,start[1],lst[1])-getH(1,1,n,start[x],lst[x]);
        }
    }
    for (ll i=1;i<=m;i++){
        cout << ans[i] <<"\n";
    }
    cerr << "\nTime elapsed: " << 1000.0 * clock() / CLOCKS_PER_SEC << " ms.\n";
    return 0;
}
