////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//////⢂⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣴⣤⣀⣴⣤⣹⣿⡷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀///////
//////⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣶⣷⣶⣾⠿⡛⠋⠸⠿⢿⣿⡟⣻⣷⣶⣦⣤⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀///////
//////⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⡿⢋⣡⣴⣿⣿⠏⣴⡷⢨⣿⡞⢨⣿⡷⣿⣇⡀⣀⠉⡉⠛⠻⠿⣶⣦⣄⡀⠀⠀⠀⠀⠀///////
//////⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣾⣿⣿⡟⣿⡿⣹⣿⠁⣽⣿⣇⢺⣿⣷⣉⣟⣻⠿⢷⣾⣴⣥⣂⡄⢉⠙⠻⢷⣦⡀⠀⠀///////
//////⠁⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠈⢿⣷⣿⣿⣿⡿⣷⢿⡯⢹⡟⠹⣯⣽⣿⠙⠛⠛⠻⠿⢿⣶⣬⣭⣛⣿⣷⣾⣦⣄⣙⣿⠀⠀///////
//////⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣾⠿⠛⠉⠀⠀⣠⣿⢇⣻⣧⠀⠀⠉⠛⠀⠀⠀⠀⠀⠀⠀⠉⠛⠻⢿⣿⣾⣽⣿⠿⠋⠀⠀///////
//////⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⠿⠋⠀⠀⠀⠀⠀⠀⠈⣿⣿⡟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⢷⣿⡄⠀⠀⠀///////
//////⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⡿⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣶⡀⠀///////
//////⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⠏⠁⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡝⢿⣦///////
//////⠀⠀⠀⠀⠀⠀⣰⣿⠟⠁⠀⠀⠀⢠⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⡆⠻///////
//////⠀⠀⠀⠀⣀⣼⡿⠁⠀⠀⠀⠀⣰⡟⢿⡀⠀⠀⠀⠀⠀⠀⠀⠀⢰⡿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡷⠀⠀⠀⠀⢠⠀⠀⠀⠀⠀⠹⡄///////
//////⠀⣴⣶⡿⠿⠋⠀⠀⠀⠀⢀⣼⠏⠀⠸⣧⠀⠀⠀⠀⠀⠀⠀⠀⣿⠃⠙⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⢛⠀⠀⠀⠀⣾⣃⠀⠀⠀⠀⠨⡑///////
//////⠀⠻⣿⣦⣴⡾⠃⠀⠀⣠⣿⣃⠀⠀⠀⠹⣆⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⠈⢙⣦⣀⡤⠄⠒⠀⠀⠀⢌⠀⢠⣴⣾⣿⣏⡶⣤⡀⠀⠀⢣///////
//////⠀⠀⠈⢻⣿⠁⠀⠀⣴⣿⡉⣙⠷⣶⣤⣤⣽⣇⠀⠀⠀⠀⠀⣿⡶⠶⢶⣻⣛⣻⡟⣦⡀⠀⠀⠀⠀⢎⡀⠀⠉⢿⣿⣿⣿⢃⠁⠀⠀⡡///////
//////⠀⠀⢠⣿⠇⠀⢀⣾⣯⣿⣿⢿⣿⣿⢷⣬⠁⠹⣧⠀⠀⠀⢸⡏⢐⣾⠿⢿⣿⣿⢿⣿⣿⣦⣀⠀⠀⡞⡄⠀⠀⠀⢿⣿⡇⠰⠂⠀⠀⡔///////
//////⠀⠀⣾⡟⠀⢠⣿⣿⣿⠋⢰⣾⣿⢿⣿⣧⠀⠀⠘⢷⣄⠀⣿⠁⠀⢀⣾⣿⠿⢿⣿⣮⡙⢿⣿⣷⣴⡸⡁⠀⠀⠀⠘⣿⠃⠀⠏⡀⠰⢠///////
//////⠀⣼⡿⠁⠀⠸⣿⣿⣧⠀⢸⣿⣧⣬⣿⣿⠆⠀⠀⠀⠙⢷⡟⠀⠀⣼⣿⣯⣀⣸⣿⣿⣗⠈⢿⣿⣿⡿⣇⠀⠀⠀⠀⢹⠁⠀⢱⢀⠃⢆///////
//////⣾⣿⠇⠀⠀⢸⣯⠉⠻⠷⠻⠿⠟⠻⠛⠋⠀⢀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠻⠿⢿⣿⣿⣿⡀⢘⣿⣿⣿⣟⠀⠀⠀⠀⠀⠀⡀⠸⡄⡉⠆///////
//////⣿⡟⠀⠀⠆⣿⡯⠠⡁⢆⡐⠠⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠠⠄⡀⠂⠄⡉⠍⡙⢋⠍⠡⣿⣏⠀⠀⠀⠀⠀⠀⡰⠈⣇⠘⡰///P///
//////⣿⠁⠀⠀⣸⣿⠁⢂⠁⠂⠄⠡⠈⠀⢠⣶⣦⣤⣶⣶⢦⣷⣾⢶⣄⠀⠀⠡⢀⠉⠰⢀⠎⢄⠡⡈⢅⢻⡇⠀⠀⠀⠀⠀⠀⡜⡀⢿⠠⣁///A///
//////⡿⠀⠀⢠⣿⡇⠀⢂⠈⠐⠈⡀⠈⠀⣿⡟⢭⡘⢤⠒⡢⢆⡹⠟⡿⣷⡀⠀⠀⡈⠀⠂⠈⢀⠂⠐⠈⣿⠇⠀⠀⠀⠀⠀⡰⠡⠄⢺⡐⠄///I///
//////⠇⠀⠀⠘⣿⣧⠂⠀⠀⠀⢀⠀⠀⢸⡿⣈⠦⡑⢎⡱⡑⢎⠴⡩⢔⡩⣷⡄⠀⠀⢀⠀⠠⠀⠀⠄⣸⡿⠀⠀⠀⠀⠀⢠⢁⡃⠆⢸⡅⢊///M///
//////⠀⠀⠀⠀⠹⣿⣆⠐⠀⠈⠀⠀⠀⢸⣿⢠⢣⡙⢦⠱⣉⢎⠲⡑⢎⠴⣹⣧⠀⠀⠀⠀⠀⠄⠀⢠⣿⠇⠀⠀⠀⠀⢠⠃⢢⡘⠄⢸⡆⡅///O///
//////⡇⠀⠀⠀⢰⡹⣿⣷⣄⠀⠀⠀⠀⠘⣿⢆⠣⡜⢢⠓⡌⢎⡱⣉⢎⠲⣹⢿⡄⠀⠀⠀⠀⠀⢠⣿⡟⠀⠀⠀⢀⠰⡁⠎⡔⠌⡄⢸⡇⠰///N///
//////⣿⡀⠀⠀⠀⢅⠢⡙⢿⣿⣶⣥⡀⢀⣹⣯⡓⣌⠣⣙⠸⢄⡃⠖⣌⠣⣌⣿⡇⡀⠀⠂⣠⣶⣿⡟⡀⠀⡀⠜⢢⠑⡌⠒⡌⡘⠀⡾⢄⢃///////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
	
#include <bits/stdc++.h>
#define ll long long
#define ld long double 
#define inf 0x3f3f3f3f
#define FILE "GCDIX"
using namespace std;
//**Variable**//
int n, q;
int A[100006];
int u, v;
int t, l, r, x;
vector<int> g[100006];
int h[100006];
int chainHead[100006];
int chainPos[100006];
int par[100006];
int sz[100006];
int node[100006];
int curPos ;
ll lazy[400006+5];
ll T[400006+5];
//**Struct**//

//**Function**//
void lz(int id){
	if(lazy[id]==0)return;
	lazy[id*2]+= lazy[id];
	lazy[id*2+1]+= lazy[id];
	lazy[id] = 0;
}
void buildVal(int id, int l, int r){
	if(l>r)return;
	if(l==r) return lazy[id] = A[node[l]], void();
	int mid = (l+r)/2;
	buildVal(id*2,l,mid);
	buildVal(id*2+1,mid+1,r);
}
void updateVal(int id, int l, int r, int u, int v, int val){
	if(r<l || r<u || v<l || v<u)return;
	if(u<=l && r<=v){	
		lazy[id]+=val;
		return ;
	}
	int mid = (l+r)/2;
	lz(id);
	updateVal(id*2,l,mid,u,v,val);
	updateVal(id*2+1,mid+1,r,u,v,val);
}
ll getVal(int pos){
	int id = 1, l = 1, r = n;
	while(l<r){
		int m = (l + r)/2;
		lz(id);
		if(pos<=m){
			id = id*2;
			r = m;
		}
		else{
			id = id*2 + 1;
			l = m + 1;
		}
	}
	return lazy[id];
}
void buildGCD(int id, int l, int r){
	if(l>r)return;
	if(l==r)return T[id] = A[node[l]] - A[node[l-1]], void();
	int mid = (l+r)/2;
	buildGCD(id*2,l,mid);
	buildGCD(id*2+1,mid+1,r);
	T[id] = gcd(T[id*2],T[id*2+1]);
}
void updateGCD(int pos, int val){
	int id = 1, l = 1, r = n;
	while(l<r){
		int m = (l + r)/2;
		if(pos<=m){
			id = id*2;
			r = m;
		}
		else{
			id = id*2 + 1;
			l = m + 1;
		}
	}
	T[id]+=val;
	while ( id > 1){
		id/=2;
		T[id] = gcd(T[id*2],T[id*2+1]);
	}
}
ll getGCD(int id, int l, int r, int u, int v){
	if(r<l || r<u || v<l || v<u)return 0;
	if(u<=l && r<=v){
		return T[id];
	}
	int mid = (l+r)/2;
	ll left = getGCD(id*2,l,mid,u,v);
	ll right = getGCD(id*2+1,mid+1,r,u,v);
	return gcd(left,right);
}
void dfs(int u, int p){
	sz[u] = 1;
	for(auto v : g[u]){
		if(v!=p){
			h[v] = h[u] + 1;
			par[v] = u; 
			dfs(v,u);
			sz[u] += sz[v];
		}
	}	
}
void hld(int u, int p, int head){
	chainHead[u] = head;
	chainPos[u] = ++curPos;
	node[curPos] = u;
	int nxt = -1;
	for(auto v : g[u]){
		if(v!=p){
			if(nxt==-1 || sz[v] > sz[nxt]) nxt = v;
		}
	}
	if(nxt!=-1)
		hld(nxt,u,head);
	for(auto v : g[u]){
		if(v != nxt && v != p){
			hld(v,u,v);
		}
	}
}
void updateHld(int u, int v, int val){
	while(chainHead[u] != chainHead[v]){
		if(h[chainHead[u]] < h[chainHead[v]]) swap(u,v);
		updateVal(1,1,n,chainPos[chainHead[u]],chainPos[u],val);
		updateGCD(chainPos[chainHead[u]],val);
		if(chainPos[u]+1 <= n) 
			updateGCD(chainPos[u]+1, -val);
		u = par[chainHead[u]];
	}

	if( chainPos[u] > chainPos[v] )swap(u,v);
	updateVal(1,1,n,chainPos[u],chainPos[v],val);
	updateGCD(chainPos[u],val);
	if(chainPos[v]+1 <= n) 
		updateGCD(chainPos[v]+1,-val);
}
ll solve(int u, int v){
	ll res = 0;
	ll val = 0;
	while(chainHead[u] != chainHead[v]){
		if(h[chainHead[u]] < h[chainHead[v]]) swap(u,v);
		val = getVal(chainPos[chainHead[u]]);
		res = gcd(res, val);
		if(chainPos[chainHead[u]]+1<=n){
			val = getGCD(1,1,n,chainPos[chainHead[u]]+1,chainPos[u]);
			res = gcd(res,val);
		}
		u = par[chainHead[u]];
	}
	if( chainPos[u] > chainPos[v] )swap(u,v);
	val = getVal(chainPos[u]);
	res = gcd(res,val);
	if(chainPos[u]+1 <= chainPos[v]){
		val = getGCD(1,1,n,chainPos[u]+1,chainPos[v]);
		res = gcd(res,val);
	}
	return res;
}
void preprocess(){
 	dfs(1,-1);
    hld(1,-1,1);
    buildVal(1,1,n);
    buildGCD(1,1,n);
}
int main()
{
    ios_base::sync_with_stdio(false);cin.tie(NULL);
    // freopen(FILE".inp","w",stdout);
    freopen(FILE".inp","r",stdin);
    freopen(FILE".out","w",stdout);
    cin>>n>>q;
    for(int i = 1; i<=n; i++){
    	cin>>A[i];
    }
    for(int i = 1; i<n; i++){
    	cin>>u>>v;
    	g[u].push_back(v);
    	g[v].push_back(u);
    }
   	preprocess();
   	// for(int i = 1; i<=n; i++){
   		// cout<<h[i]<<"\n";
   	// }
    while(q--){
    	cin>>t;
    	if(t == 1){
    		cin>>l>>r>>x;
    		updateHld(l,r,x);
    	}else{
    		cin>>l>>r;
    		cout<<solve(l,r)<<"\n";
    	}
    }
    return 0;
}
